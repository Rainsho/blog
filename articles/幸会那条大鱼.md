# 幸会，那条大鱼

> 2018 年 5 月 3 日，非科班出身的我，带着不到两年的前端开发经验走进了「斗鱼」的大家庭。对我而言，能够加入「斗鱼」，这是莫大的信任和也是非凡的机遇。选花名的时候，我放弃了一直使用的英文名，而是选了「小鱼」，寓意自己能够保持空杯心态，持续精进，从一条「小鱼」做起，成长为一条像「斗鱼」一样的「大鱼」。一年过去，回头看那些踩过的坑和走过的路，还是想保持初心。对「斗鱼」说一句，幸会，那条大鱼！

## 初来乍到

### 持续集成

初来乍到被安排做持续集成方向的工作。记忆犹新的是那天被 Scott 带到了「用户沉淀」会议室，向我还有另外一位同学介绍持续集成的技术选型和未来的开发方向。对于当时还不了解公司开发流程并且从来没听说过 Docker 和 drone 的我，简直是云里雾里，一脸懵逼。

### Shark 2.0

除了知道要做持续集成，第二个接触到的应该就是为主站重构所设计的 Shark 2.0 框架了。自诩对 React 技术栈还比较了解的我，如果说之前是「看山是山」的境界，那么当我了解了 Shark 2.0 的体系以后，绝对是「看山不是山」的状态。除了熟悉的组件化(React)和状态管理(Redux)。Shark 2.0 引入了众多 JS 领域的新特性，比如响应式编程范式(RxJS)，副作用的隔离(Redux-Observable)，甚至只是在后端领域常见的依赖注入、装饰器、Schema 校验。这一切永葆了 Shark 2.0 的先进性，当然也无可避免的让一个新手有了更多的功课需要准备。

### 第一份挑战

所幸「罗马不是一天建成的」，Docker 和 Shark 2.0 构成了我接下来几个月的重点工作内容。而我入职遇到的第一份挑战，应该是 Shark CI 的前端开发。基于公司已有的众多内部项目经验，技术选型 ant-design-pro，花了一个周末的时间熟悉 redux-saga 和 dva，第二周一开始便开动了。差不多花了两周的时间，完成了 Shark CI 前端从 0 到 1 的初版开发。往后，经过几次迭代和功能扩展，逐渐有了现在看到的 Shark CI。同时集 CI/CD 一体的，前端工程化系统。

## 下半场

如果说 Q2 的两个月，还是在作为一个传统的前端工程师，开发页面和接口联调。那么从 Q3 开始，伴随着核心业务重构工作的全面展开。我也更彻底的转换角色，成为了一名从工程化角度提供开发支撑的人员。不论是围绕着 Shark CI 的功能扩展，还是基于 Docker 定制化的容器开发，再或者是面向 Shark 2.0 核心库的维护与优化。都能感受到每行代码是在为业务所用，都有它带来的可量化的价值。以下内容，摘自 Q3 总结：

> - 构建效率优化
>
>   - 核心业务重构构建的持续优化，单次构建时间由约 8min（7 月数据）提升至约 90s
>   - 为 XX 平台提供专项构建优化，单次构建时间由约 5min 提升至约 30s
>   - 为 XX 中台提供专项构建优化，大幅度缩小构建搜索范围，解决了服务器资源频繁耗尽的问题
>   - 为 XX 器提供专项构建优化，实现与主站共用依赖，减小包体积约 30%，同时大幅提升了构建时间
>
> - 加载性能优化
>
>   - 核心业务重构加载性能的持续优化，DOMContentLoaded 和 Load 指标时间由 7 月的约 600ms + 8s 提升至目前的约 300ms + 800ms
>   - 专项优化 XX 器加载策略，播放器加载前的预编译代码由约 1500K 压缩至约 800K
>   - 专项优化加载梯队及 XX 加载策略，采用原生 Promise 替换原 rxjs 的事件实现，提升加载效率约 40%
>
> - 包裁剪优化
>
>   - 核心业务重构包裁剪的持续优化，业务代码及第三方库由峰值时约 13MB 裁剪至目前约 4MB
>
> - 兼容性问题排查
>
>   - 核心业务重构兼容性问题持续排查，定位及修复大量至 IE9 版本的兼容性问题，确保了重构代码对 IE9 及以上浏览器的支持

如果说 Q2 是一个从无到有，Q3 是从有到好的过程，那么 Q4 一定是一个从好到优的过程。随着重构和发布工作的日益稳定。更多的精力放在了一些专项的优化和一些脚手架辅助工具的开发上面。也遇到了我的良师益友月无痕同学，他有一句话，让我映像深刻「一个优秀的库作者，都是非常良心的人，是想的更多的人」。也是基于这个理念在 Q4 不论是 `@shark/build` 这类已有的工具库的重构，还是一些新的辅助工具库，诸如 `@shark/link-helper` 或者 `@shark/roll` 的开发，都不仅仅只是完成基本的功能。而都会从易用性、扩展性和错误提示上考虑优化设计，甚至花一定的时间在 CLI 的交互处理上。

## 前端工程化

老实说，提到前端工程化。在部门听到最多的抱怨就是，「工程化对我们来讲，就是一个黑盒」。于是乎，借着这次总结，我也想思考一下，到底前端工程化是什么？到底我们做了哪些(可能有遗漏)，而哪些方面还有待提高。

### 模块化

- [x] 针对 JS 文件，不论是基于 Webpack + Babel 的同步加载，还是多 chunk 的异步加载，甚至是跨仓库、跨项目的外部依赖复用，都有较完善和成熟的支持方式
- [ ] 针对 CSS 文件，较多的是使用 Postcss 进行编译，但并没有具有针对性的模块化支持
- [x] 针对资源文件，借助 Webpack 实现模块化支持

### 组件化

模块化更多的是文件层面的，而组件化更多的是功能层面。例如核心业务重构时的加载策略和拆包策略，都是组件化的体现。

### 规范化

- [x] 目录结构制定
- [x] 编码规范
- [x] 文档规范
- [x] ESLint
- [x] StyleLint
- [x] Commit 描述规范
- [x] Git 分支管理
- [ ] CodeReview

### 自动化

- [x] 持续集成
- [x] 自动构建
- [x] 自动发布
- [ ] 自动测试
- [x] 雪碧图自动合并
- [x] SVG 自动合并
- [x] webp 图片自动转换
- [x] webp 样式自动生成
- [x] 样式文件自动合并
- [x] 模版片段自动生成
- [x] 开发环境自动热加载
- [x] 内网 sourcemap 自动定位

### 优化

- [x] 构建效率优化
- [x] 构建体积优化
- [x] 加载性能优化
- [x] 兼容性优化

## 简单总结这一年

- 在内网和这里写过一些经验总结
- 基础没丢，还是个能用 React 写复杂页面的小前端
- 有过那么几个小项目，负责了从建库建表到部署的完整后端和运维工作
- 踩过单测的坑
- 也踩过 IE 的坑
- 设计过估计很反 Webpack 初衷的模块共享和通讯解决方案
- 写了一些 Docker 容器
- 写过很多 Webpack 配置文件
- 也写了很多插件，有 Webpack 的，有 Postcss 的，也有 Babel 的
- 写了一些看起来挺有用的工具库、CLI
- 读了很多文档，弄懂了 AST、CRP、Marbles
- 收集了很多工具库，也读了其中一些的源码，永远坚信 no magic~

## 未来

入职的时候，老大问我未来有什么规划。我说，希望从前端做起，然后是全栈，然后是架构师，再往后如果能做到 CTO 那就完美了。而如今，我想我的初心不曾改变，对于技术也一直都是一种开放的心态。但也慢慢的有所感悟，「知识」和「能力」并不对等。也许我今年一年可以看 100 个新的技术或者框架的用法，但这并不见得能提升我的编程能力、架构能力，或者是工程能力。往前，我可能更看重技术栈的扩充，所谓的「看山不是山」；往后，还是会继续拓宽技术栈，但更重要的是基础能力的提升。毕竟，「any application that can be written in JavaScript, will eventually be written in JavaScript」，嗯，到最后「看山还是山」。
